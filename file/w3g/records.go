// Author:  Niels A.D.
// Project: gowarcraft3 (https://github.com/nielsAD/gowarcraft3)
// License: Mozilla Public License, v2.0

package w3g

import (
	"io"
	"strings"
	"unicode"

	"github.com/nielsAD/gowarcraft3/protocol/w3gs"
)

// GameInfo record [0x10]
//
// Format:
//
//       Size   | Name
//   -----------+--------------------------
//       4 byte | Number of host records
//     variable | PlayerInfo for host
//     variable | GameName (null terminated string)
//       1 byte | Nullbyte
//     variable | Encoded String (null terminated)
//              |  - GameSettings
//              |  - Map&CreatorName
//       4 byte | PlayerCount
//       4 byte | GameType
//       4 byte | LanguageID
//
type GameInfo struct {
	HostPlayer   PlayerInfo
	GameName     string
	GameSettings w3gs.GameSettings
	GameFlags    w3gs.GameFlags
	NumSlots     uint32
	LanguageID   uint32
}

// Serialize encodes the struct into its binary form.
func (rec *GameInfo) Serialize(s *Stream) error {
	s.WriteUInt8(RidGameInfo)

	s.WriteUInt32(1)
	rec.HostPlayer.SerializeContent(s)

	s.WriteCString(rec.GameName)
	s.WriteUInt8(0)

	rec.GameSettings.SerializeContent(&s.Buffer)
	s.WriteUInt32(rec.NumSlots)
	s.WriteUInt32(uint32(rec.GameFlags))
	s.WriteUInt32(rec.LanguageID)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *GameInfo) Deserialize(s *Stream) error {
	if s.Size() < 24 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	if s.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}

	if err := rec.HostPlayer.DeserializeContent(s); err != nil {
		return err
	}

	if s.Size() < 15 {
		return io.ErrShortBuffer
	}

	var err error
	if rec.GameName, err = s.ReadCString(); err != nil {
		return err
	}

	if s.Size() < 14 {
		return io.ErrShortBuffer
	}
	if s.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	if err := rec.GameSettings.DeserializeContent(&s.Buffer); err != nil {
		return err
	}

	if s.Size() < 12 {
		return io.ErrShortBuffer
	}

	rec.NumSlots = s.ReadUInt32()
	rec.GameFlags = w3gs.GameFlags(s.ReadUInt32())
	rec.LanguageID = s.ReadUInt32()

	return nil
}

// PlayerInfo record [0x16]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//     1 byte   | PlayerID
//     n bytes  | PlayerName (null terminated string)
//     1 byte   | size of additional data:
//              |  0x01 = custom
//              |  0x08 = ladder
//
//   * If custom (0x1):
//       1 byte    | null byte (1 byte)
//   * If ladder (0x08):
//       4 bytes   | runtime of players Warcraft.exe in milliseconds
//       4 bytes   | player race flags:
//                 |   0x01=human
//                 |   0x02=orc
//                 |   0x04=nightelf
//                 |   0x08=undead
//                 |  (0x10=daemon)
//                 |   0x20=random
//                 |   0x40=race selectable/fixed
//
type PlayerInfo struct {
	ID          uint8
	Name        string
	Race        w3gs.RacePref
	JoinCounter uint32
}

// Serialize encodes the struct into its binary form.
func (rec *PlayerInfo) Serialize(s *Stream) error {
	s.WriteUInt8(RidPlayerInfo)
	rec.SerializeContent(s)
	s.WriteUInt32(0)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *PlayerInfo) Deserialize(s *Stream) error {
	if s.Size() < 9 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	if err := rec.DeserializeContent(s); err != nil {
		return err
	}

	// Skip unknown
	if s.Size() < 4 {
		return io.ErrShortBuffer
	}
	s.Skip(4)

	return nil
}

// SerializeContent encodes the struct into its binary form without record ID.
func (rec *PlayerInfo) SerializeContent(s *Stream) {
	s.WriteUInt8(rec.ID)
	s.WriteCString(rec.Name)

	if rec.JoinCounter == 0 && rec.Race == 0 {
		s.WriteUInt8(1)
		s.WriteUInt8(0)
	} else {
		s.WriteUInt8(8)
		s.WriteUInt32(rec.JoinCounter)
		s.WriteUInt32(uint32(rec.Race))
	}
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (rec *PlayerInfo) DeserializeContent(s *Stream) error {
	if s.Size() < 4 {
		return io.ErrShortBuffer
	}

	rec.ID = s.ReadUInt8()

	var err error
	if rec.Name, err = s.ReadCString(); err != nil {
		return err
	}

	if s.Size() < 2 {
		return io.ErrShortBuffer
	}

	var len = s.ReadUInt8()
	if s.Size() < int(len) {
		return io.ErrShortBuffer
	}

	switch len {
	case 0x01, 0x02:
		s.Skip(int(len))
		fallthrough
	case 0x00:
		rec.JoinCounter = 0
		rec.Race = 0
	case 0x08:
		rec.JoinCounter = s.ReadUInt32()
		rec.Race = w3gs.RacePref(s.ReadUInt32())
	default:
		return ErrUnexpectedConst
	}

	return nil
}

// PlayerLeft record [0x17]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | reason
//              |  0x01 - connection closed by remote game
//              |  0x0C - connection closed by local game
//              |  0x0E - unknown (rare) (almost like 0x01)
//      1 byte  | PlayerID
//      1 dword | result - see table below
//      1 dword | unknown (number of replays saved this warcraft session?)
//
type PlayerLeft struct {
	Local    bool
	PlayerID uint8
	Reason   w3gs.LeaveReason
	Counter  uint32
}

// Serialize encodes the struct into its binary form.
func (rec *PlayerLeft) Serialize(s *Stream) error {
	s.WriteUInt8(RidPlayerLeft)
	if rec.Local {
		s.WriteUInt32(0x0C)
	} else {
		s.WriteUInt32(0x01)
	}
	s.WriteUInt8(rec.PlayerID)
	s.WriteUInt32(uint32(rec.Reason))
	s.WriteUInt32(rec.Counter)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *PlayerLeft) Deserialize(s *Stream) error {
	if s.Size() < 14 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	switch s.ReadUInt32() {
	case 0x01, 0x0E:
		rec.Local = false
	case 0x0C:
		rec.Local = true
	default:
		return ErrUnexpectedConst
	}

	rec.PlayerID = s.ReadUInt8()
	rec.Reason = w3gs.LeaveReason(s.ReadUInt32())
	rec.Counter = s.ReadUInt32()

	return nil
}

// SlotInfo record [0x19]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//     1 word   | number of data bytes following
//     1 byte   | nr of SlotRecords following (== nr of slots on startscreen)
//     n bytes  | nr * SlotRecord
//     1 dword  | RandomSeed
//     1 byte   | SelectMode
//              |   0x00 - team & race selectable (for standard custom games)
//              |   0x01 - team not selectable
//              |          (map setting: fixed alliances in WorldEditor)
//              |   0x03 - team & race not selectable
//              |          (map setting: fixed player properties in WorldEditor)
//              |   0x04 - race fixed to random
//              |          (extended map options: random races selected)
//              |   0xcc - Automated Match Making (ladder)
//     1 byte   | StartSpotCount (nr. of start positions in map)
//
//   For each slot:
//     1 byte   | player id (0x00 for computer players)
//     1 byte   | map download percent: 0x64 in custom, 0xff in ladder
//     1 byte   | slotstatus:
//              |   0x00 empty slot
//              |   0x01 closed slot
//              |   0x02 used slot
//     1 byte   | computer player flag:
//              |   0x00 for human player
//              |   0x01 for computer player
//     1 byte   | team number:0 - 11
//              | (team 12 == observer or referee)
//     1 byte   | color (0-11):
//              |   value+1 matches player colors in world editor:
//              |   (red, blue, cyan, purple, yellow, orange, green,
//              |    pink, gray, light blue, dark green, brown)
//              |   color 12 == observer or referee
//     1 byte   | player race flags (as selected on map screen):
//              |   0x01=human
//              |   0x02=orc
//              |   0x04=nightelf
//              |   0x08=undead
//              |   0x20=random
//              |   0x40=race selectable/fixed
//     1 byte   | computer AI strength: (only present in v1.03 or higher)
//              |   0x00 for easy
//              |   0x01 for normal
//              |   0x02 for insane
//              | for non-AI players this seems to be always 0x01
//     1 byte   | player handicap in percent (as displayed on startscreen)
//              | valid values: 0x32, 0x3C, 0x46, 0x50, 0x5A, 0x64
//              | (field only present in v1.07 or higher)
//
type SlotInfo struct {
	w3gs.SlotInfo
}

// Serialize encodes the struct into its binary form.
func (rec *SlotInfo) Serialize(s *Stream) error {
	s.WriteUInt8(RidSlotInfo)
	rec.SerializeContent(&s.Buffer)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *SlotInfo) Deserialize(s *Stream) error {
	if s.Size() < 10 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	return rec.DeserializeContent(&s.Buffer)
}

// GameStart record [0x1C]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | unknown (always 0x01 so far)
//
type GameStart struct{}

// Serialize encodes the struct into its binary form.
func (rec *GameStart) Serialize(s *Stream) error {
	s.WriteUInt8(RidGameStart)
	s.WriteUInt32(0x01)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *GameStart) Deserialize(s *Stream) error {
	if s.Size() < 5 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	if s.ReadUInt32() != 0x01 {
		return ErrUnexpectedConst
	}

	return nil
}

// CountDownStart record [0x1A]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | unknown (always 0x01 so far)
//
type CountDownStart struct {
	GameStart
}

// Serialize encodes the struct into its binary form.
func (rec *CountDownStart) Serialize(s *Stream) error {
	s.WriteUInt8(RidCountDownStart)
	s.WriteUInt32(0x01)
	return nil
}

// CountDownEnd record [0x1B]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | unknown (always 0x01 so far)
//
type CountDownEnd struct {
	GameStart
}

// Serialize encodes the struct into its binary form.
func (rec *CountDownEnd) Serialize(s *Stream) error {
	s.WriteUInt8(RidCountDownEnd)
	s.WriteUInt32(0x01)
	return nil
}

// TimeSlot record [0x1E] / [0x1F]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//     1 word   | n = number of bytes that follow
//     1 word   | time increment (milliseconds)
//              |   about 250 ms in battle.net
//              |   about 100 ms in LAN and single player
//     n-2 byte | CommandData block(s) (not present if n=2)
//
type TimeSlot struct {
	w3gs.TimeSlot
}

// Serialize encodes the struct into its binary form.
func (rec *TimeSlot) Serialize(s *Stream) error {
	if rec.Fragment || (s.ProtocolVersion > 0 && s.ProtocolVersion <= 2) {
		s.WriteUInt8(RidTimeSlot2)
	} else {
		s.WriteUInt8(RidTimeSlot)
	}

	// Placeholder for size
	s.WriteUInt16(0)
	var start = s.Size()

	s.WriteUInt16(rec.TimeIncrementMS)

	for i := 0; i < len(rec.Actions); i++ {
		s.WriteUInt8(rec.Actions[i].PlayerID)
		s.WriteUInt16(uint16(len(rec.Actions[i].Data)))
		s.WriteBlob(rec.Actions[i].Data)
	}

	// Set size
	s.WriteUInt16At(start-2, uint16(s.Size()-start))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *TimeSlot) Deserialize(s *Stream) error {
	if s.Size() < 5 {
		return io.ErrShortBuffer
	}

	rec.Fragment = s.ReadUInt8() == RidTimeSlot2

	var size = int(s.ReadUInt16())
	if size < 2 || s.Size() < size {
		return io.ErrShortBuffer
	}

	rec.TimeIncrementMS = s.ReadUInt16()
	size -= 2

	rec.Actions = rec.Actions[:0]
	for size >= 3 {
		var action = w3gs.PlayerAction{
			PlayerID: s.ReadUInt8(),
		}

		var subsize = int(s.ReadUInt16())
		if size < subsize {
			return ErrBadFormat
		}
		size -= 3 + subsize

		action.Data = s.ReadBlob(subsize)
		rec.Actions = append(rec.Actions, action)
	}

	if size != 0 {
		return ErrBadFormat
	}

	return nil
}

// ChatMessage record [0x20]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//     1 byte   | PlayerID (message sender)
//     1 word   | n = number of bytes that follow
//     1 byte   | flags
//              |   0x10   for delayed startup screen messages
//              |   0x20   for normal messages
//     1 dword  | chat mode (not present if flag = 0x10):
//              |   0x00   for messages to all players
//              |   0x01   for messages to allies
//              |   0x02   for messages to observers or referees
//              |   0x03+N for messages to specific player N (with N = slotnumber)
//     n bytes  | zero terminated string containing the text message
//
type ChatMessage struct {
	w3gs.Message
}

// Serialize encodes the struct into its binary form.
func (rec *ChatMessage) Serialize(s *Stream) error {
	s.WriteUInt8(RidChatMessage)
	s.WriteUInt8(rec.SenderID)

	switch rec.Type {
	case w3gs.MsgChatExtra:
		s.WriteUInt16(uint16(6 + len(rec.Content)))
	case w3gs.MsgChat:
		s.WriteUInt16(uint16(2 + len(rec.Content)))
	default:
		s.WriteUInt16(2)
	}

	s.WriteUInt8(uint8(rec.Type))

	switch rec.Type {
	case w3gs.MsgChatExtra:
		s.WriteUInt32(uint32(rec.Scope))
		fallthrough
	case w3gs.MsgChat:
		s.WriteCString(rec.Content)
	default:
		s.WriteUInt8(rec.NewVal)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *ChatMessage) Deserialize(s *Stream) error {
	if s.Size() < 1 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	rec.RecipientIDs = nil
	rec.SenderID = s.ReadUInt8()
	rec.Scope = w3gs.ScopeAll
	rec.NewVal = 0
	rec.Content = ""

	var size = int(s.ReadUInt16())
	if size < 2 || s.Size() < size {
		return io.ErrShortBuffer
	}

	rec.Type = w3gs.MessageType(s.ReadUInt8())

	switch rec.Type {
	case w3gs.MsgChatExtra:
		if size < 6 {
			return ErrBadFormat
		}
		size -= 4
		rec.Scope = w3gs.MessageScope(s.ReadUInt32())
		fallthrough
	case w3gs.MsgChat:
		var err error
		if rec.Content, err = s.ReadCString(); err != nil {
			return err
		}

		// Parse extra strings (nwg quirk)
		size -= 2 + len(rec.Content)
		for size > 0 {
			s, err := s.ReadCString()
			if err != nil {
				return err
			}

			if strings.IndexFunc(s, func(r rune) bool { return !unicode.IsPrint(r) }) != -1 {
				return ErrBadFormat
			}

			rec.Content += s
			size -= len(s) + 1
		}

		if size != 0 {
			return ErrBadFormat
		}
	default:
		if size != 2 {
			return ErrBadFormat
		}
		rec.NewVal = s.ReadUInt8()
	}

	return nil
}

// TimeSlotAck record [0x22]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 byte  | number of bytes following (always 0x04 so far)
//      1 dword | checksum
//
type TimeSlotAck struct {
	Checksum []byte
}

// Serialize encodes the struct into its binary form.
func (rec *TimeSlotAck) Serialize(s *Stream) error {
	if s.ProtocolVersion == 0 || s.ProtocolVersion > 2 {
		s.WriteUInt8(RidTimeSlotAck)
	} else {
		s.WriteUInt8(RidChatMessage)
	}

	s.WriteUInt8(uint8(len(rec.Checksum)))
	s.WriteBlob(rec.Checksum)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *TimeSlotAck) Deserialize(s *Stream) error {
	if s.Size() < 2 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	var size = int(s.ReadUInt8())
	if s.Size() < size {
		return io.ErrShortBuffer
	}

	rec.Checksum = s.ReadBlob(size)
	return nil
}

// Desync record [0x23]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | unknown
//      1 byte  | unknown (always 4?)
//      1 dword | unknown (random?)
//      1 byte  | unknown (always 0?)
//
type Desync struct {
	w3gs.Desync
}

// Serialize encodes the struct into its binary form.
func (rec *Desync) Serialize(s *Stream) error {
	s.WriteUInt8(RidDesync)
	rec.SerializeContent(&s.Buffer)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *Desync) Deserialize(s *Stream) error {
	if s.Size() < 11 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	return rec.DeserializeContent(&s.Buffer)
}

// EndTimer record [0x2F]
//
// Format:
//
//    size/type | Description
//   -----------+-----------------------------------------------------------
//      1 dword | mode:
//              |   0x00 countdown is running
//              |   0x01 countdown is over (end is forced *now*)
//      1 dword | countdown time in sec
//
type EndTimer struct {
	GameOver     bool
	CountDownSec uint32
}

// Serialize encodes the struct into its binary form.
func (rec *EndTimer) Serialize(s *Stream) error {
	s.WriteUInt8(RidEndTimer)
	s.WriteBool32(rec.GameOver)
	s.WriteUInt32(rec.CountDownSec)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (rec *EndTimer) Deserialize(s *Stream) error {
	if s.Size() < 9 {
		return io.ErrShortBuffer
	}

	// Skip record ID
	s.Skip(1)

	rec.GameOver = s.ReadBool32()
	rec.CountDownSec = s.ReadUInt32()

	return nil
}
