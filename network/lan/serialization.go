// Author:  Niels A.D.
// Project: gowarcraft3 (https://github.com/nielsAD/gowarcraft3)
// License: Mozilla Public License, v2.0

package lan

import (
	"github.com/nielsAD/gowarcraft3/protocol"
	"github.com/nielsAD/gowarcraft3/protocol/w3gs"
)

// typeGameInfo RR type ID
const typeGameInfo = 66

// Sent as RRtype 66 DNS record, encoded with protobuf
type gameInfo struct {
	GameName  string
	MessageID int32
	Options   map[string]string
}

// gameInfo.Options index
const (
	idxGameID         = "game_id"
	idxGameSecret     = "game_secret"
	idxGameCreateTime = "game_create_time"
	idxGameData       = "game_data"
	idxPlayersMax     = "players_max"
	idxPlayersNum     = "players_num"
)

// Encoded as base64 string in gameInfo.Options[idxGameData]
type gameData struct {
	GameFlags    w3gs.GameFlags
	GameSettings w3gs.GameSettings
	SlotsTotal   uint32
	GameName     string
	GamePort     uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *gameData) SerializeContent(buf *protocol.Buffer, enc *w3gs.Encoding) error {
	// Reforged swapped game name and game flags records
	if enc.GameVersion == 0 || enc.GameVersion >= 10032 {
		buf.WriteCString(pkt.GameName)
		buf.WriteUInt8(0)
	} else {
		buf.WriteUInt32(uint32(pkt.GameFlags))
	}

	pkt.GameSettings.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.SlotsTotal)

	if enc.GameVersion == 0 || enc.GameVersion >= 10032 {
		buf.WriteUInt32(uint32(pkt.GameFlags))
	} else {
		buf.WriteCString(pkt.GameName)
		buf.WriteUInt8(0)
	}

	buf.WriteUInt16(pkt.GamePort)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *gameData) DeserializeContent(buf *protocol.Buffer, enc *w3gs.Encoding) error {
	if buf.Size() < 13 {
		return w3gs.ErrInvalidPacketSize
	}

	// Reforged swapped game name and game flags records
	if enc.GameVersion == 0 || enc.GameVersion >= 10032 {
		var err error
		if pkt.GameName, err = buf.ReadCString(); err != nil {
			return err
		}

		if buf.Size() < 12 {
			return w3gs.ErrInvalidPacketSize
		}
		if buf.ReadUInt8() != 0 {
			return w3gs.ErrUnexpectedConst
		}
	} else {
		pkt.GameFlags = w3gs.GameFlags(buf.ReadUInt32())
	}

	if err := pkt.GameSettings.DeserializeContent(buf, enc); err != nil {
		return err
	}

	if buf.Size() < 8 {
		return w3gs.ErrInvalidPacketSize
	}

	pkt.SlotsTotal = buf.ReadUInt32()

	if enc.GameVersion == 0 || enc.GameVersion >= 10032 {
		pkt.GameFlags = w3gs.GameFlags(buf.ReadUInt32())
		if buf.Size() != 2 {
			return w3gs.ErrInvalidPacketSize
		}
	} else {
		var err error
		if pkt.GameName, err = buf.ReadCString(); err != nil {
			return err
		}
		if buf.Size() != 3 {
			return w3gs.ErrInvalidPacketSize
		}
		if buf.ReadUInt8() != 0 {
			return w3gs.ErrUnexpectedConst
		}
	}

	pkt.GamePort = buf.ReadUInt16()

	return nil
}
