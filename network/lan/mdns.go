// Author:  Niels A.D.
// Project: gowarcraft3 (https://github.com/nielsAD/gowarcraft3)
// License: Mozilla Public License, v2.0

package lan

import (
	"fmt"
	"io"
	"net"
	"strings"
	"time"

	"github.com/miekg/dns"

	"github.com/nielsAD/gowarcraft3/network"
	"github.com/nielsAD/gowarcraft3/protocol"
	"github.com/nielsAD/gowarcraft3/protocol/w3gs"
)

// MulticastGroup endpoint
var MulticastGroup = net.UDPAddr{IP: net.IPv4(224, 0, 0, 251), Port: 5353}

// TypeCacheFlush bit
var TypeCacheFlush uint16 = 1 << 15

// TypeUnicastResponse bit
var TypeUnicastResponse uint16 = 1 << 15

// DNSPacketConn manages a UDP connection that transfers DNS packets.
// Public methods/fields are thread-safe unless explicitly stated otherwise
type DNSPacketConn struct {
	cmut network.RWMutex
	conn net.PacketConn
	msg  dns.Msg
	buf  [2048]byte
}

// NewDNSPacketConn returns conn wrapped in DNSPacketConn
func NewDNSPacketConn(conn net.PacketConn) *DNSPacketConn {
	return &DNSPacketConn{
		conn: conn,
	}
}

// Conn returns the underlying net.PacketConn
func (c *DNSPacketConn) Conn() net.PacketConn {
	c.cmut.RLock()
	var conn = c.conn
	c.cmut.RUnlock()
	return conn
}

// SetConn closes the old connection and starts using the new net.PacketConn
func (c *DNSPacketConn) SetConn(conn net.PacketConn) {
	c.Close()
	c.cmut.Lock()
	c.conn = conn
	c.cmut.Unlock()
}

// Close the connection
func (c *DNSPacketConn) Close() error {
	c.cmut.RLock()

	var err error
	if c.conn != nil {
		err = c.conn.Close()
	}

	c.cmut.RUnlock()

	return err
}

// Send pkt to addr over net.PacketConn
func (c *DNSPacketConn) Send(addr net.Addr, pkt *dns.Msg) (int, error) {
	c.cmut.RLock()

	if c.conn == nil {
		c.cmut.RUnlock()
		return 0, io.EOF
	}

	var n = 0

	raw, err := pkt.Pack()
	if err == nil {
		n, err = c.conn.WriteTo(raw, addr)
	}
	c.cmut.RUnlock()

	return n, err
}

// Broadcast a packet over LAN
func (c *DNSPacketConn) Broadcast(pkt *dns.Msg) (int, error) {
	return c.Send(&MulticastGroup, pkt)
}

// NextPacket waits for the next packet (with given timeout) and returns its deserialized representation
// Not safe for concurrent invocation
func (c *DNSPacketConn) NextPacket(timeout time.Duration) (*dns.Msg, net.Addr, error) {
	c.cmut.RLock()

	if c.conn == nil {
		c.cmut.RUnlock()
		return nil, nil, io.EOF
	}

	if timeout != 0 {
		if err := c.conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {
			c.cmut.RUnlock()
			return nil, nil, err
		}
	}

	size, addr, err := c.conn.ReadFrom(c.buf[:])
	if err != nil {
		c.cmut.RUnlock()
		return nil, nil, err
	}

	err = c.msg.Unpack(c.buf[:size])
	c.cmut.RUnlock()

	if err != nil {
		return nil, nil, err
	}

	return &c.msg, addr, err
}

// Run reads packets (with given max time between packets) from Conn and emits an event for each received packet
// Not safe for concurrent invocation
func (c *DNSPacketConn) Run(f network.Emitter, timeout time.Duration) error {
	c.cmut.RLock()
	f.Fire(network.RunStart{})
	for {
		pkt, addr, err := c.NextPacket(timeout)

		if err != nil {
			switch err.(type) {
			// Connection is still valid after these errors, only deserialization failed
			case *dns.Error:
				f.Fire(&network.AsyncError{Src: "Run[NextPacket]", Err: err})
				continue
			default:
				f.Fire(network.RunStop{})
				c.cmut.RUnlock()
				return err
			}
		}

		f.Fire(pkt, addr)
	}
}

func mdnsService(gv *w3gs.GameVersion) string {
	return strings.ToLower(fmt.Sprintf("_%s%x._sub._blizzard._udp.local.", gv.Product.String(), gv.Version))
}

const typeGameInfo = 66

// Sent as type 66 DNS record, encoded with protobuf
type gameInfo struct {
	GameName  string
	MessageID int32
	Options   map[string]string
}

const (
	idxGameID         = "game_id"
	idxGameSecret     = "game_secret"
	idxGameCreateTime = "game_create_time"
	idxGameData       = "game_data"
	idxPlayersMax     = "players_max"
	idxPlayersNum     = "players_num"
)

// Encoded as base64 string in gameInfo.Options[idxGameData]
type gameData struct {
	GameFlags    w3gs.GameFlags
	GameSettings w3gs.GameSettings
	SlotsTotal   uint32
	GameName     string
	GamePort     uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *gameData) SerializeContent(buf *protocol.Buffer, enc *w3gs.Encoding) error {
	buf.WriteUInt32(uint32(pkt.GameFlags))
	pkt.GameSettings.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.SlotsTotal)
	buf.WriteCString(pkt.GameName)
	buf.WriteUInt8(0)
	buf.WriteUInt16(pkt.GamePort)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *gameData) DeserializeContent(buf *protocol.Buffer, enc *w3gs.Encoding) error {
	if buf.Size() < 12 {
		return w3gs.ErrInvalidPacketSize
	}
	pkt.GameFlags = w3gs.GameFlags(buf.ReadUInt32())

	if err := pkt.GameSettings.DeserializeContent(buf, enc); err != nil {
		return err
	}
	if buf.Size() < 7 {
		return w3gs.ErrInvalidPacketSize
	}

	pkt.SlotsTotal = buf.ReadUInt32()

	var err error
	if pkt.GameName, err = buf.ReadCString(); err != nil {
		return err
	}

	if buf.Size() != 3 {
		return w3gs.ErrInvalidPacketSize
	}
	if buf.ReadUInt8() != 0 {
		return w3gs.ErrUnexpectedConst
	}

	pkt.GamePort = buf.ReadUInt16()
	return nil
}
